---
// è½®æ’­å›¾æ•°æ®
const carouselItems = [
    { src: '/images/carousel/grid-7.png', alt: 'äº§å“ç»†èŠ‚ç‰¹å†™ 1' },
    { src: '/images/carousel/grid-8.png', alt: 'äº§å“ç»†èŠ‚ç‰¹å†™ 2' },
    { src: '/images/carousel/grid-2.png', alt: 'äº§å“ç»†èŠ‚ç‰¹å†™ 3' },
];

interface Props {
    title: string; // æ¨¡å—ä¸»æ ‡é¢˜
    featureImage: string; // å·¦ä¾§å›ºå®šå›¾ç‰‡
    featureAlt: string; // å·¦ä¾§å›¾ç‰‡çš„ Alt æ–‡æœ¬
}

const { title, featureImage, featureAlt } = Astro.props;

// å”¯ä¸€çš„ ID ç”¨äº JS äº¤äº’
const carouselId = `carousel-${Math.random().toString(36).substring(2, 9)}`;

// å…‹éš†ç¬¬ä¸€å¼ å’Œæœ€åä¸€å¼ å›¾ç‰‡ç”¨äºæ¨¡æ‹Ÿæ— é™å¾ªç¯
const firstItemClone = carouselItems[0];
const totalOriginalItems = carouselItems.length;
const lastItemClone = carouselItems[totalOriginalItems - 1];

// è½¨é“æ€»é¡¹ç›®æ•°ï¼šåŸå§‹é¡¹ + 2ä¸ªå…‹éš†é¡¹
const totalTrackItems = totalOriginalItems + 2;
---

<section class="module-2-image-split">

    <div class="module-2-image-inner">

        <h2 class="module-title">
            {title}
        </h2>

        <div class="content-split-wrapper">

            <div class="split-column static-image-column">
                <img
                    src={featureImage}
                    alt={featureAlt}
                    class="static-img-element"
                    loading="lazy"
                    decoding="async"
                >
            </div>

            <div id={carouselId} class="split-column carousel-slider-column carousel-track-wrapper">

                <div class="carousel-inner-track">
                    {/* é€»è¾‘ä½ç½®ç´¢å¼• 0: å…‹éš†æœ€åä¸€é¡¹ (ä»å¤´å‘å·¦æ»‘) */}
                    <div class="slide-item clone" data-index="-1" aria-hidden="true">
                        <img
                            src={lastItemClone.src}
                            alt={lastItemClone.alt}
                            class="slide-img"
                            loading="lazy"
                            decoding="async"
                        />
                    </div>

                    {/* é€»è¾‘ä½ç½®ç´¢å¼• 1 åˆ° totalOriginalItems: åŸå§‹é¡¹ */}
                    {carouselItems.map((item, index) => (
                        <div class="slide-item" data-index={index}>
                            <img
                                src={item.src}
                                alt={item.alt}
                                class="slide-img"
                                loading="lazy"
                                decoding="async"
                            />
                        </div>
                    ))}
                    {/* é€»è¾‘ä½ç½®ç´¢å¼• totalOriginalItems + 1: å…‹éš†ç¬¬ä¸€é¡¹ (ä»å°¾å‘å³æ»‘) */}
                    <div class="slide-item clone" data-index={totalOriginalItems} aria-hidden="true">
                        <img
                            src={firstItemClone.src}
                            alt={firstItemClone.alt}
                            class="slide-img"
                            loading="lazy"
                            decoding="async"
                        />
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<script define:vars={{ carouselId, totalOriginalItems, totalTrackItems }} is:inline>
    // --- å¸¸é‡é…ç½® ---
    const SLIDE_TRANSITION_TIME_MS = 800;
    const AUTOPLAY_DELAY = 5000;
    const SWIPE_THRESHOLD_PIXELS = 50;
    const SLIDE_GAP = 30; // ä¸ CSS ä¸­çš„ gap ä¿æŒä¸€è‡´

    function initializeOptimizedCarousel() {
        const wrapper = document.getElementById(carouselId);
        if (!wrapper) return;
        const innerTrack = wrapper.querySelector('.carousel-inner-track');

        // --- çŠ¶æ€ ---
        let isDragging = false;
        let startX = 0;
        let currentDragDistance = 0;
        let lastTranslateX = 0;
        let autoplayInterval;
        let animationFrameId = null;
        let currentIndex = 1;
        let isTransitioning = false;

        // --- å·¥å…·å‡½æ•° ---
        const getClientX = (evt) => (evt.touches ? evt.touches[0].clientX : evt.clientX);

        // è®¡ç®—å•ä¸ªé¡¹ç›®åº”å æ®çš„å®Œæ•´å®½åº¦ (åŒ…æ‹¬é—´éš™)
        const getItemFullWidth = () => {
             // wrapper å®½åº¦ç­‰äºä¸€ä¸ª slide-item çš„å®½åº¦
             // å®é™…ä¸Šï¼Œä¸€ä¸ª slide-item çš„å®½åº¦æ˜¯ wrapper çš„å®½åº¦
             // æ‰€ä»¥ ItemFullWidth = slide-item.offsetWidth + gap
            const item = innerTrack.querySelector('.slide-item');
            if (!item) return 0;
            return item.offsetWidth + SLIDE_GAP;
        };

        const applyTransform = (x) => {
            innerTrack.style.transform = `translateX(${x}px)`;
        };

        const setTransition = (enabled) => {
            innerTrack.style.transition = enabled ? `transform ${SLIDE_TRANSITION_TIME_MS}ms ease-out` : 'none';
        };

        // åŠ¨ç”»æ›´æ–°å¾ªç¯ (rAF): ä¿è¯æ‹–åŠ¨æµç•…æ€§
        const updatePosition = () => {
            if (!isDragging) return;
            // æ‹–åŠ¨æ—¶çš„ä½ç½® = ä¸Šæ¬¡å¸é™„ä½ç½® + æ‹–åŠ¨è·ç¦»
            const newX = lastTranslateX + currentDragDistance;
            applyTransform(newX);
            animationFrameId = requestAnimationFrame(updatePosition);
        };

        // --- æ ¸å¿ƒæ“ä½œ ---

        /**
         * ç¬é—´è·³è½¬åˆ°ç›®æ ‡ç´¢å¼• (ç”¨äºæ— é™å¾ªç¯çš„é‡ç½®)
         * @param {number} targetIndex - ç›®æ ‡é€»è¾‘ç´¢å¼• (0 æˆ– totalOriginalItems)
         */
        const instantMoveTo = (targetIndex) => {
            isTransitioning = false;
            const fullWidth = getItemFullWidth();
            if (fullWidth === 0) return;

            const newX = -targetIndex * fullWidth;
            setTransition(false); // ç§»é™¤è¿‡æ¸¡

            requestAnimationFrame(() => {
                applyTransform(newX);
                lastTranslateX = newX;
                currentIndex = targetIndex;
            });
        };

        /**
         * å¹³æ»‘åˆ‡æ¢åˆ°ç›®æ ‡ç´¢å¼• (åŸºäº transitionend äº‹ä»¶)
         * @param {number} targetIndex - ç›®æ ‡é€»è¾‘ç´¢å¼•
         */
        const smoothMoveTo = (targetIndex) => {
            if (isTransitioning) return; // é˜²æ­¢é‡å¤è§¦å‘
            isTransitioning = true;

            const fullWidth = getItemFullWidth();
            if (fullWidth === 0) return;

            const newX = -targetIndex * fullWidth;

            // 1. è®¾ç½®è¿‡æ¸¡
            setTransition(true);
            requestAnimationFrame(() => {
                applyTransform(newX);
                lastTranslateX = newX;
                currentIndex = targetIndex;
            });

            // 2. ç›‘å¬è¿‡æ¸¡ç»“æŸäº‹ä»¶ï¼Œæ‰§è¡Œç¬é—´è·³è½¬
            const handleTransitionEnd = (event) => {
                // ç¡®ä¿æ˜¯ transform å±æ€§çš„è¿‡æ¸¡ç»“æŸäº‹ä»¶
                if (event.propertyName !== 'transform') return;

                // ç§»é™¤ç›‘å¬å™¨ï¼Œé¿å…å†…å­˜æ³„æ¼
                innerTrack.removeEventListener('transitionend', handleTransitionEnd);

                // æ£€æŸ¥å½“å‰æ˜¯å¦åœ¨å…‹éš†é¡¹ä¸Š
                if (targetIndex === 0) {
                    instantMoveTo(totalOriginalItems); // è·³åˆ°æœ€åä¸€ä¸ªåŸå§‹é¡¹
                } else if (targetIndex === totalTrackItems - 1) {
                    instantMoveTo(1); // è·³åˆ°ç¬¬ä¸€ä¸ªåŸå§‹é¡¹
                }

                isTransitioning = false; // é‡ç½®çŠ¶æ€
            };

            // åªæœ‰å½“ç›®æ ‡æ˜¯å…‹éš†é¡¹æ—¶æ‰éœ€è¦ç›‘å¬ transitionend
            if (targetIndex === 0 || targetIndex === totalTrackItems - 1) {
                innerTrack.addEventListener('transitionend', handleTransitionEnd);
            } else {
                // å¦‚æœæ˜¯æ™®é€šåˆ‡æ¢ï¼Œè¿‡æ¸¡ç»“æŸåç›´æ¥è§£é™¤ transitioning çŠ¶æ€
                 setTimeout(() => {
                    isTransitioning = false;
                 }, SLIDE_TRANSITION_TIME_MS + 50); // å¢åŠ å°‘é‡å†—ä½™æ—¶é—´
            }
        };

        // è‡ªåŠ¨æ’­æ”¾é€»è¾‘
        const nextSlide = () => {
            const nextIndex = currentIndex + 1;
            smoothMoveTo(nextIndex);
        };

        // --- äº‹ä»¶å¤„ç† ---

        const handleStart = (evt) => {
            // æ‹–åŠ¨å¼€å§‹æ—¶ï¼Œå¦‚æœæ­£åœ¨è¿‡æ¸¡ï¼Œåˆ™åœæ­¢å¹¶ç«‹å³å¸é™„
            if (isTransitioning) {
                // å¼ºåˆ¶ç»“æŸå½“å‰çš„è¿‡æ¸¡ï¼Œå®šä½åˆ°æ­£åœ¨è¿‡æ¸¡çš„æœ€ç»ˆç›®æ ‡ä½ç½®
                setTransition(false);
                applyTransform(lastTranslateX);
                isTransitioning = false;
            }

            stopAutoplay();

            isDragging = true;
            wrapper.style.cursor = 'grabbing';

            startX = getClientX(evt);
            currentDragDistance = 0;

            if (animationFrameId === null) {
                animationFrameId = requestAnimationFrame(updatePosition);
            }

            if (evt.type === 'mousedown') evt.preventDefault();
        };

        const handleMove = (evt) => {
            if (!isDragging) return;
            const x = getClientX(evt);
            currentDragDistance = x - startX;
        };

        const handleEnd = (evt) => {
            if (!isDragging) return;

            isDragging = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            wrapper.style.cursor = 'grab';

            const dragDistance = currentDragDistance;
            const fullWidth = getItemFullWidth();
            if (fullWidth === 0) return;

            // åŸºäºæ‹–åŠ¨ç»“æŸæ—¶çš„æœ€ç»ˆä½ç½®è®¡ç®—æœ€è¿‘çš„ç´¢å¼•
            const finalPosition = lastTranslateX + dragDistance;
            const nearestIndex = Math.round(Math.abs(finalPosition) / fullWidth);
            let targetIndex = nearestIndex;

            // åˆ¤æ–­æ˜¯å¦è¶…è¿‡åˆ‡æ¢é˜ˆå€¼ (å¼ºåˆ¶åˆ‡æ¢åˆ°ä¸Šä¸€å¼ æˆ–ä¸‹ä¸€å¼ )
            if (Math.abs(dragDistance) > SWIPE_THRESHOLD_PIXELS) {
                targetIndex = dragDistance > 0 ? nearestIndex - 1 : nearestIndex + 1;
            }

            // ç¡®ä¿ç´¢å¼•åœ¨è½¨é“èŒƒå›´å†… [0, totalTrackItems - 1]
            targetIndex = Math.max(0, targetIndex);
            targetIndex = Math.min(totalTrackItems - 1, targetIndex);

            // å¹³æ»‘å¸é™„åˆ°ç›®æ ‡ä½ç½®
            smoothMoveTo(targetIndex);

            startAutoplay();
        };

        // å¯åŠ¨/åœæ­¢è‡ªåŠ¨æ’­æ”¾
        const startAutoplay = () => {
            if (autoplayInterval) clearInterval(autoplayInterval);
            autoplayInterval = setInterval(nextSlide, AUTOPLAY_DELAY);
        };
        const stopAutoplay = () => {
            clearInterval(autoplayInterval);
            autoplayInterval = null;
        };


        // --- ç»‘å®šäº‹ä»¶ ---
        wrapper.addEventListener('mousedown', handleStart);
        wrapper.addEventListener('touchstart', handleStart, { passive: true });

        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);

        wrapper.addEventListener('touchmove', handleMove, { passive: true });
        wrapper.addEventListener('touchend', handleEnd);

        const handleResize = () => {
            // çª—å£å¤§å°å˜åŒ–åï¼Œé‡æ–°è®¡ç®—å®½åº¦ï¼Œå¹¶å®šä½åˆ°å½“å‰æ˜¾ç¤ºçš„é€»è¾‘ç´¢å¼• (currentIndex)
            instantMoveTo(currentIndex);
        };
        window.addEventListener('resize', handleResize);

        // åˆå§‹åŒ–å¯åŠ¨ï¼Œå®šä½åˆ°ç¬¬ä¸€ä¸ªçœŸå®é¡¹ç›® (ç´¢å¼• 1)
        instantMoveTo(1);
        startAutoplay();
        wrapper.style.cursor = 'grab';
    }

    initializeOptimizedCarousel();
</script>

<style>
/* ------------------------------------- */
/* 1. æ¨¡å—åŸºç¡€æ ·å¼å’Œå…¨å®½ Hack (æ€§èƒ½ä¼˜åŒ–) */
/* ------------------------------------- */

.module-2-image-split {
    content-visibility: auto;
    contain: layout style;

    width: 100vw;
    position: relative;
    left: 50%;
    right: 50%;
    margin-left: -50vw;
    margin-right: -50vw;
    z-index: 1;

    padding-top: 80px;
    padding-bottom: 80px;
}

.module-2-image-inner {
    width: 100%;
    max-width: 1920px;
    margin: 0 auto;
}

.module-2-image-split .module-title {
    font-size: clamp(1.8em, 3vw, 2.5em);
    margin-bottom: 40px;
    color: #333;
    margin-left: 64px;
    margin-right: 64px;
    text-align: left;
    font-family: 'Manetta-Montserrat', sans-serif;
    font-weight: 300;
}

/* ------------------------------------- */
/* 2. å·¦å³åˆ†æ  Flex å¸ƒå±€ */
/* ------------------------------------- */

.content-split-wrapper {
    display: flex;
    justify-content: center;
    gap: 10%;
    margin-left: 64px;
    margin-right: 64px;
}

.split-column {
    flex: 0 0 45%;
}

/* é™æ€å›¾ç‰‡åˆ— */
.static-image-column {
    /* ğŸš€ é™æ€å›¾ç‰‡ä¹Ÿå¼ºåˆ¶ 1:1 */
    aspect-ratio: 1 / 1;
}

.static-img-element {
    width: 100%;
    height: 100%;
    display: block;
    /* ğŸš€ ä¿æŒ cover ä»¥å¡«å……ï¼Œæˆ–æ”¹ä¸º contain ä»¥å®Œæ•´æ˜¾ç¤º */
    object-fit: cover;
    box-shadow: none;
    border-radius: 0;
    border: none;
}

/* è½®æ’­å®¹å™¨ */
.carousel-slider-column {
    align-self: stretch;
}

/* è½¨é“å®¹å™¨ï¼šè´Ÿè´£è£å‰ªï¼Œç§»é™¤æ‰€æœ‰æ»šåŠ¨æ¡ç›¸å…³æ ·å¼ */
.carousel-track-wrapper {
    width: 100%;
    /* ğŸš€ å…³é”®ï¼šé«˜åº¦ç”±å­å…ƒç´ çš„ aspect-ratio å†³å®šï¼Œæˆ–è€…ç›´æ¥è®¾ç½®ä¸º 1:1 */
    aspect-ratio: 1 / 1; /* ç¡®ä¿æ•´ä¸ªè½®æ’­åŒºåŸŸä¹Ÿæ˜¯ 1:1 */
    overflow: hidden;
    border-radius: 8px;

    cursor: grab;

    scrollbar-width: none;
    -ms-overflow-style: none;
}
.carousel-track-wrapper::-webkit-scrollbar {
    display: none;
}


/* è½®æ’­å†…éƒ¨è½¨é“ */
.carousel-inner-track {
    will-change: transform;

    display: flex;
    gap: 30px;
    /* ğŸš€ å…³é”®ï¼šé«˜åº¦ç»§æ‰¿è‡ªçˆ¶å®¹å™¨ï¼Œç¡®ä¿å†…éƒ¨ flex item å¯ä»¥æ’‘å¼€ */
    height: 100%;

    /* å®½åº¦ç”± JS å’Œ CSS å˜é‡åŠ¨æ€è®¡ç®— */
    width: calc(100% * var(--total-items));

    user-select: none;
    -webkit-user-select: none;

    transition: none; /* é»˜è®¤ä¸å¼€å¯è¿‡æ¸¡ï¼Œç”± JS åŠ¨æ€æ§åˆ¶ */
}

/* å•ä¸ªè½®æ’­é¡¹ */
.slide-item {
    /* ğŸš€ å…³é”®ï¼šå®½åº¦è®¡ç®— (100% / å•æ¬¡æ˜¾ç¤ºçš„å›¾ç‰‡æ•°é‡) - é—´éš™ */
    /* æˆ‘ä»¬æ¯æ¬¡åªæ˜¾ç¤ºä¸€å¼ å›¾ç‰‡ï¼Œæ‰€ä»¥ flex-basis æ˜¯ 100% / 1ï¼Œå†å‡å»é—´éš™ */
    flex: 0 0 calc(100% - 30px); /* 100% å¯¹åº” wrapper çš„å®½åº¦ */
    box-sizing: border-box;
    /* ğŸš€ å…³é”®ï¼šå¼ºåˆ¶ 1:1 æ¯”ä¾‹ */
    aspect-ratio: 1 / 1;
    height: auto; /* é«˜åº¦ç”± aspect-ratio æ§åˆ¶ */
}

.slide-img {
    width: 100%;
    height: 100%;
    /* ğŸš€ ä¿æŒ cover å¡«å…… 1:1 åŒºåŸŸ (å¯èƒ½è£å‰ª)ï¼Œæˆ–æ”¹ä¸º contain å®Œæ•´æ˜¾ç¤º (å¯èƒ½ç•™ç™½) */
    object-fit: cover;
    display: block;
    border-radius: 8px;
    pointer-events: none;
}


/* ------------------------------------- */
/* 3. å“åº”å¼è°ƒæ•´ */
/* ------------------------------------- */

@media (max-width: 1024px) {
    .module-2-image-split .module-title,
    .content-split-wrapper {
        margin-left: 48px;
        margin-right: 48px;
    }
    .content-split-wrapper {
        gap: 20px;
    }
    .split-column {
        flex: 0 0 45%;
    }
}

@media (max-width: 768px) {
    .content-split-wrapper {
        flex-direction: column;
        justify-content: flex-start;
        gap: 30px;
        margin-left: 20px;
        margin-right: 20px;
    }

    .module-2-image-split .module-title {
        margin-left: 20px;
        margin-right: 20px;
    }

    .split-column {
        flex: 0 0 100%;
    }

    .static-image-column {
        aspect-ratio: 1 / 1; /* æ‰‹æœºç«¯ä¹Ÿä¿æŒ 1:1 */
    }

    .carousel-slider-column {
        align-self: auto;
        aspect-ratio: 1 / 1; /* æ‰‹æœºç«¯ä¹Ÿä¿æŒ 1:1 */
    }
}
</style>